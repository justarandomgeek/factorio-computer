* `CPU Mk3.book.lua`: a Foreman Exported Book of all the logic modules required to build the CPU. Each module links to the main bus by matching colors as described below. The modules can also be imported individually by copy/pasting their blueprint string from the book file.
* `*.blueprint.lua`: Foreman Blueprint Scripts for various modules that must vary with installed mods. Details on each script can be found in it's associated modules section.
* `scalarmap.lua`: A machine descriptor file generated by ScalarGen.
* `compiler.*`: A compiler (in C# and Lua) that transforms source files into blueprint strings for a strips of constant combinators configured as a ROM.


![Image](screenshot_30924151.png)
![Image](screenshot_30933153.png)



## Machine Structure

### Main Bus Signals

Major signals are labeled with floor concrete. In general pairs will be kept together for single-color poles, but when a pole must carry mixed pairs, the left side is colored for the green wire, and the right side for red wire.

For wiring clarity, it is recommended to remove power wires from poles and only carry power at substations.

| Pole Color | Green Wire | Red Wire |
|------------|------------|----------|
| Red        | Keyboard                      | Keyboard             |
| Orange     | Op Pulse                      | rStatus              |
| Yellow     | Op                            | To PC                |
| Green      | R1                            | Scalars              |
| Cyan       | R2                            | Vector Result        |
| Blue       | Scalar Result (`signal-grey`) | rIndex               |
| Purple     | Memory Read Request           | Memory Read Response |
| Magenta    |                               | Memory Write         |
| White      | NixieTerm                     | NixieTerm            |
| Hazard     | IO Wire                       | IO Wire              |
| FireHazard | IO Wire Register              | IO Wire Register     |

* Scalars
	* signal-grey: R1.s1
	* signal-white: R2.s2
* To PC
	* signal-blue: next
	* signal-green: rjmp to signal-grey
	* signal-red: jump to signal-grey
  * signal-pink: execute this frame as an instruction
  * signal-yellow: Hold. Prevents execution of instructions while set.
  * signal-cyan: Interrupt. Next update (except exec) will save return site in rStatus and jump to interrupt vector.
* rStatus
  * signal-blue: PC
  * signal-green: Interrupt Return site
  * signal-cyan: Interrupt Request
  * signal-I: Interrupt Enable


### Machine Blocks

The machine is made of several independant functional blocks which each connect to the main bus.

* White: PC update, Instruction Fetch & Decode
* White: IO Wire Port
* Black: NixieTerm
* Black: Registers
* Red: ALU
* Blue: Scalar Pick & Return
* Purple: Memory Controller
* Purple: RAM
* Magenta: Flow Control
* Yellow+Hazard: Debug controls

#### ScalarGen and Scalar Pick & Return

The Scalar Pick & Return mechanism allows operating on individual signals from registers. There are two Pick channels, s1 and s2, and one Return channel sd, selected by the corresponding signals in the current opcode, and operating on the corresponding register selection. Because the signals available will vary depending on what mods are installed, this module is generated by a script, ScalarGen. ScalarGen is executed by pasting it into Foreman's import window as if it were a blueprint string, and will add a blueprint named ScalarGen to your list. It will also produce a file `scalarmap.lua` in your script-output directory listing the numeric mappings for the assembly it has generated, which must be used when compiling programs for your computer. The local bus generated by ScalarGen is, from left to right, Blue,Yellow,Cyan,Green.

#### ALU

The ALU computes every operation possible in parallel, and the selected operation is returned on Vector/Scalar result.

#### ALU Pairwise Multiply/Add

This block is generated by MaskGen. The local bus generated by MaskGen is, from left to right, Orange,Cyan,Green.

The Pairwise ALU block is generated by a script to allow working with all signals in the game. This block performs pairwise Multiply/Add operations on the operands and returns the result to Vector Result. This block is optional and if not installed Ops 61 and 62 will halt the machine.

#### Debug controls

The 'Stepping' button toggles between step and run modes. In step mode, the PC Update commands are cached in the debugger until released by the 'Step' button. The debugger's buffer can also be manipulated directly to adjust program flow, using the four buttons above the command display. In run mode, PC Update commands are run immediately.

#### Registers

Registers store an entire circuit network frame, except `signal-black`. `signal-black` is used internally for various scalar and flag values throughout the machine, and cannot be stored in registers/memory, or expressed correctly in most mechanisms.


| ID    | Name        | Purpose |
|-------|-------------|---------|
| 0     | `rNull`     | No Register selected. Returns 0 on every signal.|
| 1-8   | `r1`-`r8`   | General Purpose data registers. |
| 9     | `rIndex`    | Indexing regiser. Supports auto-indexing memory operations. |
| 10    | `rRed`      | IO Wire Red data since list transmitted |
| 11    | `rGreen`    | IO Wire Green data since last transmitted |
| 12    | `rStat`     | CPU Status register |
| 13    | `rOp`       | Current Op data |
| 14    | `rNixie`    | NixieTerm |
| 15,16 | `rFlanRX`,`rFlanTX`| Wireless masts
| 17    | `rKeyboard` | Keyboard interface. Reads a single buffered key. Clear buffer with `signal-grey`. |
| 18+   |  `r18`-...  | IO Expansion ports<br>Aditional devices may be connected to these registers |

#### Calling Conventions

* **Call Stack:** The call stack is stored on Stack 1.
* **Call-saved registers:** r1-r4 must be saved/restored by the called subroutine if used.
* **Call-used registers:** r5-r7 may be used freely by the called subroutine.
* **Compiler scratch register:** r8 is used by the compiler for saving/restoring call site in function, and other temporary usage in generated code.
* **Call-saved stacks:** Stack 2 must be saved/restored by the called subroutine if used.
* **Call-used stacks:** Stacks 3-4 may be used freely by the called subroutine. r8 is used by the compiler for saving/restoring call site in function.

Call arguments are passed via `r5-r7`, filling down from `r7`, then spilled to the call stack. Local data are allocated the same as arguments, immediately after them. Return value is passed in `r5`.


### Operations

The following signals are used to select registers and signals:

| Signal  |Purpose|
|--------|-------|
|signal-0|Op|
|signal-A| Accumulate |
|signal-I| Index/Stack Select
|signal-R|R1|
|signal-S|S1|
|signal-T|R2|
|signal-U|S2|
|signal-V|Rd|
|signal-W|Sd|
|signal-grey|Imm1|
|signal-white|Imm2|

If Rd is set, the selected register will be cleared as Op Pulse is triggered unless Accumulate is also set (>0), even if the current operation does not actually assign to it. The whole register will be cleared, even in scalar operations.

For operations which support memory indexing, the base pointers are selected as follows:

|  I  |Signal         | Usage      |
|-----|---------------|------------|
|  1  |`signal-red`   | Call Stack |
|  2  |`signal-green` | Callee Preserved |
|  3  |`signal-blue`  | Callee argument/scratch |
|  4  |`signal-yellow`| Callee argument/scratch |


Individual instructions may also define additional signals. Any unused signals should be left unset.

#### 0: Halt
Any undefined opcode will halt the machine, but Op=0 is specifically reserved for doing so.

#### 1-60: ALU Operations
The ALU performs every possible operation in parallel, and returns the requested operation's result to Scalar Result or Vector Result.

|    |Comparisons|Arithmetic|
|----|-----------|----------|
|Output|<ul><li>0: Vector</li><li>24: Scalar</li></ul>|<ul><li>48: Vector</li><li>52: Scalar</li></ul></td>
| Operator | <ul><li>1:`=`</li><li>2:`<`</li><li>3:`>`</li></ul> | <ul><li>1:`-`</li><li>2:`+`</li><li>3:`/`</li><li>4:`*`</li></ul>
| Output Mode | <ul><li>0:`?=` Input Value</li><li>3:`?1` Flags</li></ul> | |
| Input Mode | <ul><li>0: Every</li><li>6: Any</li><li>12: Scalar</li><li>18: Each</li></ul> | <ul><li>0: Each</li><li>4: Scalar</li></ul>

Add one value from each cell of a column to form an instruction.

#### 61: Pairwise Vector Multiply
R1.each * R2.each pairwise => Rd

#### 62: Pairwise Vector Add
R1.each + R2.each pairwise => Rd

#### 63: Scalar Array Pick (exec)
* R1.[R2.s2] -> Rd.sd
  * exec{0=58,R=R,S=[R2.s2],V=V,W=W,A=A}

#### 64: Scalar Array Write (exec)
* R1.s1 -> Rd.[R2.s2]
  * exec{0=58,R=R,S=S,V=V,W=[R2.s2],A=A}

#### 6?: Scalar shift up
R1 >> R2.s2 -> Rd

#### 6?: Scalar shift down
R1 << R2.s2 -> Rd

#### 70: Jump
Jump to R1.s1 if `signal-green`=0 or PC+R1.s1 if `signal-green`=1. Return PC+1 to Rd.Sd.

#### 71: Branch
Returns PC+1 to Rd.sd. Compares R1.s1 to R2.s2, and makes the following jumps:

* `=` PC+rOp.1
* `<` PC+rOp.2
* `>` PC+rOp.3

#### 72: Exec
Execute the contents of R1 as an instruction, at the current PC value.

#### 80: Wire
Write a packet to a two-wire network, and clear the receive registers for a response. To leave either wire untouched, select `rNull` for it. `rRed` and `rGreen` are cleared on the same frame the selected signals are transmitted. Write `rNull` to both wires to clear the receive buffer without transmitting anything.
* R1=>Red Wire
* R2=>Green Wire
* 0=>rRed,rGreen

#### 81: Write Memory
Write the contents of R2 to the memory location or memory-mapped device selected by R1.s1. If `signal-I` is set, the memery access is offset from the selected pointer.

* R2 -> [R1.s1+I]

#### 82: Read Memory
Read the memory location or memory-mapped device selected by R1.s1 into Rd. If `signal-I` is set, the memery access is offset from the selected pointer.

* [R1.s1+I] -> Rd

#### 83: Push
Store a frame to one of the stacks in rIndex, as selected by `signal-I`.

* R2 -> [rIndex.stack-1]
* rIndex.stack--


#### 84: Pop
Retrieve a frame to one of the stacks in rIndex, as selected by `signal-I`.

* [rIndex.stack] -> Rd
* rIndex.stack++


#### 85: Append (not currently implemented)
Store a frame to an array in one of the index pointers. Arrays are selected as described for Push. R1 must also be set to rIndex.

* R2 -> [rIndex.stack++]


## IO Devices

### NixieTerm

NixieTerm is a multi-line Alpha Nixie display. It can be accessed as an array of bit-packed strings in memory starting at `[500]`, or the lowermost row can be accessed as a `rNixie`, and shifted upward.

Any signals written in register mode will be added to the sum for the lowermost row. Writing `signal-grey` will shift all rows upward and clear the lower row. Color signals may be bit-packed along with characters.

A numeric value may also be written to a row on `signal-white` which will display in the left column of the corresponding display row.

NixieTerm supports all the characters supported by the Alpha Nixie:
* A-Z0-9 as their correspnding signals
* . as `train-stop`
* \- as `fast-splitter`

### Wireless

A cluster of wireless masts are connected on `rFlanRX`/`r15` and `rFlanTX`/`r16`. `rFlanRX` reads the current values on the wireless (including current transmitted signal). `rFlanTX` is a memory cell which is connected to transmit to the wireless. There are 12 masts connected, by default configured to relay all virtual signals except `signal-black`, leaving 16 slots available for custom configuration. Additional masts may be wired in as needed.
